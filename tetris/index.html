<!DOCTYPE html>
<html>
<head>
    <title>Tetris</title>
    <meta charset="utf-8" />
    <script src="../libraries/three.min.js"></script>
    <script src="../libraries/stats.min.js"></script>
    <script src="../libraries/dat.gui.min.js"></script>
    <script src="../libraries/controls/gameControl.js"></script>
    <script src="../libraries/controls/gameButton.js"></script>
    <script src="../libraries/helpers/utils.js"></script>
    <script src="../libraries/textContainer/textContainer.js"></script>
    <script src="../libraries/helpers/timer.js"></script>
    <script src="../libraries/helpers/timer.js"></script>
    <script src="../libraries/form/button.js"></script>
    <script src="../libraries/form/divGroup.js"></script>
    <script src="../libraries/form/form.js"></script>
    <script src="../libraries/form/label.js"></script>
    <script src="../libraries/form/selector.js"></script>
    <script src="../libraries/form/textInput.js"></script>
    <script src="../libraries/socketConnection.js"></script>
    <script src="blocks/blockController.js"></script>
    <script src="blocks/quadBlock.js"></script>
    <script src="blocks/wireframe.js"></script>
    <script src="blocks/cube.js"></script>
    <script src="blocks/scoreController.js"></script>
    <link rel="stylesheet" href="../styles/style.css" />
<head>
<script>
    var MAX_WIDTH = 1000;
    var GAME_COLUMNS = 10;
    var GAME_ROWS = 25;
    var CAM_DISTANCE = 20;
    var THETA = 1e-6;
    var BLOCK_THRESHOLDTIME = 1;
    var BLOCK_VELOCITY = 4;
    var MOVE_LEFT = "left";
    var SERVER_MOVE_LEFT = "server_left";
    var MOVE_RIGHT = "right";
    var SERVER_MOVE_RIGHT = "server_right";
    var MOVE_UP = "up";
    var SERVER_MOVE_UP = "server_up";
    var MOVE_DOWN = "down";
    var SERVER_MOVE_DOWN = "server_down";
    // global variables
    var renderer;
    var scene;
    var camera;
    var stats;
    var control;
    var orthoCamera;
    var orthoScene;
    var blockController;
    var displayController;
    var textContainer;
    var timer;
    var scoreController;
    var socketConnection;
    var formDiv;
    var form;
    var cubeShadow;

    function init() {
        
        orthoCamera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, 
                                                window.innerHeight / 2, window.innerHeight / -2, -500, 1000);
        orthoCamera.position.set(0, 0, 0);

        orthoScene = new THREE.Scene();

        var geometry = new THREE.BoxGeometry(430, 200, 1);
        var material = new THREE.MeshBasicMaterial({color: 0xffaaff});
        var c = new THREE.Mesh(geometry, material);
        c.position.set(0, 0, -499);
        orthoScene.add(c);

        // position and point the camera to the center of the scene
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        scene = new THREE.Scene();
        camera.position.set(0, 0, CAM_DISTANCE);
        camera.lookAt(scene.position);

        displayGameInfo();
        initScoreListener();
        var maxWidth = getWidthFromDistance(CAM_DISTANCE, camera, MAX_WIDTH / window.innerHeight);
        var maxHeight = getHeightFromDistance(CAM_DISTANCE, camera);
        blockController = 
            new BlockController(scene, maxWidth, maxHeight, GAME_COLUMNS, GAME_ROWS, scoreController.scoreChanged, scoreController);

        // create the stats
        stats = createStats();
        document.body.appendChild(stats.domElement);

        control = new function () {
            this.gameSpeed = BLOCK_VELOCITY;
            this.thresholdTime = BLOCK_THRESHOLDTIME;
        };
        addControls(control);

        // create a render, sets the background color and the size
        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0xAFAFAF, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.autoClear = false;

        // add the output of the renderer to the html element
        document.body.appendChild(renderer.domElement);

        //origin to left top
        var fieldWidth = blockController.getFieldWidth();
        var fieldHeight = blockController.getFieldHeight();
        scene.position.set(-fieldWidth / 2, -(fieldHeight - blockController.tileSize) / 2, 0);

        //debug
        var debugGroup = new THREE.Object3D();
        for(var x = 0; x < GAME_COLUMNS; ++x) {
            for(var y = 0; y < GAME_ROWS; ++y) {
                var c = new Cube(x * blockController.tileSize, y * blockController.tileSize, 0.1, 0xaaaaaa, 0x000000);
                debugGroup.add(c.cube);
            }
        }
        debugGroup.name = 'debug';
        scene.add(debugGroup);
      
        createForm();
    }
    
    function startGame() {
        setupKeyControls();
        setupOnScreenControls();
        startTimer(textContainer.getTextElement('time'));
        now = Date.now();
        blockController.generateBlock();
        render();
    }

    function createStats() {
        var stats = new Stats();
        stats.setMode(0);

        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';

        return stats;
    }

    function resize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        var maxWidth = getWidthFromDistance(CAM_DISTANCE, camera, MAX_WIDTH / window.innerHeight);
        var maxHeight = getWidthFromDistance(CAM_DISTANCE, camera);
        blockController.resize(maxWidth, maxHeight);
    }

    var now = 0;
    function render() {
        BLOCK_VELOCITY = control.gameSpeed;
        BLOCK_THRESHOLDTIME = control.thresholdTime;
        requestAnimationFrame(render);
        renderer.clear();
        renderer.render(orthoScene, orthoCamera);
        renderer.clearDepth();
        renderer.render(scene, camera);
        if(blockController.isGameOver) {
            return;
        }
        var diff = Date.now() - now;
        blockController.update(diff / 1000);
        stats.update();
        now = Date.now();
    }

    function addControls(controlObject) {
        var gui = new dat.GUI();
        gui.add(controlObject, 'gameSpeed', 0, 8);
        gui.add(controlObject, 'thresholdTime', 0.5, 20000);
    }

    function displayGameInfo() {
        textContainer = new TextContainer('textContainer', [{
            id: 'score',
            label: 'Score: ',
            value: '0'
        }, {
            id: 'delay',
            label: 'Delay: ',
            value: '0'
        }, {
            id: 'time',
            label: 'Time: ',
            value: '0'
        }]);
        
        document.body.appendChild(textContainer.domElement);
    }

    function initScoreListener() {
        scoreController = new ScoreController(textContainer.getTextElement('score'));
    }

    function startTimer(textElement) {
        timer = new Timer(textElement);
        timer.start();
    }

    function createForm() {
        formDiv = new DivGroup('centered');
        var serverInput = new TextInput({
            name: 'server', 
            value: 'ws://demos.kaazing.com/echo',
            label: 'Enter echo server',
            labelClass: 'label', 
            groupClass: 'formgroup',
            onFocusOut: checkConnection
        });
        var selection = new Selector({
            name: 'type',
            values: [
                { value: 0, name: 'value1' },
                { value: 1, name: 'value2' },
                { value: 2, name: 'value3' },
                { value: 3, name: 'value4' }
            ],
            label: 'Choose type',
            labelClass: 'label',
            groupClass: 'formgroup',
            btnClass: 'selectButton'
        });
        form = new Form({
            formClass: 'form',
            children: [serverInput, selection],
            submitText: 'start game!',
            submitClass: 'startButton',
                onSubmit: function(result) {
                // call the render function
                formDiv.hide();
                startGame();
            }
        });
        formDiv.domElement.appendChild(form.domElement);
        document.body.appendChild(formDiv.domElement);
        form.disable();
    }

    function checkConnection(url, element) {
        if(!socketConnection) {
            socketConnection = new SocketConnection(url, 
                textContainer.getTextElement('delay'), {
                onOpen: socketOnOpen,
                onMessage: moveRemote,
                onError: socketOnError,
                onClose: socketOnClose
            });
        } else if(socketConnection.getUrl() != url) {
            socketConnection.connect(url);
        }
    }

    function socketOnOpen() {
        form.setInfoText("Connection Successfull");
        form.enable();
    }

    function socketOnMessage(msg) {
    }

    function socketOnError(err) {
        var errorMsg = 'Error: ';
        if(err) {
            errorMsg += err;
        } else {
            errorMsg += 'The provided Url is not valid';
        }
        form.setInfoText(errorMsg);
    }
    
    function socketOnClose() {
        form.setInfoText("Connection Closed");
    }  

    function setupOnScreenControls() {
        displayController = new OnScreenController(CONTROL_MODE_ALL, {
            groupTop: '80%',
            leftButtonClass: "left",
            rightButtonClass: "right",
            upButtonClass: "up",
            downButtonClass: "down",
            clickColor: "red",
            leftPos: "left:35%;",
            rightPos: "right:35%;",
            upPos: "top:0%;left:47%;",
            downPos: "bottom:10%;left:47%;",
            leftCB: moveLeft,
            rightCB: moveRight,
            upCB: moveUp,
            downCB: moveDown
        });
        document.body.appendChild(displayController.domElement);
    }
      
    function setupKeyControls() {
        document.onkeydown = function(e) {
            switch(e.keyCode) {
                case 37: moveLeft();
                break;
                case 39: moveRight();
                break;
                case 38: moveUp();
                break;
                case 40: moveDown();
                break;
            }
        }
    }

    function moveRemote(message) {
        switch(message) {
            case MOVE_LEFT:
            case SERVER_MOVE_LEFT: blockController.moveLeft();
            break;
            case MOVE_RIGHT:
            case SERVER_MOVE_RIGHT: blockController.moveRight();
            break;
            case MOVE_UP:
            case SERVER_MOVE_UP: blockController.rotate();
            break;
            case MOVE_DOWN:
            case SERVER_MOVE_DOWN: blockController.moveFast();
            break;
        }
    }

    function moveLeft() {
        displayController.leftClicked();
        blockController.moveShadowLeft();
        sendToServer(MOVE_LEFT);
    }

    function moveRight() {
        blockController.moveShadowRight();
        displayController.rightClicked();
        sendToServer(MOVE_RIGHT);

    }

    function moveUp() {
        displayController.upClicked();
        sendToServer(MOVE_UP);
    }

    function moveDown() {
        displayController.downClicked();
        sendToServer(MOVE_DOWN);
    }

    function sendToServer(message) {
        socketConnection.send(message);
    }

    // calls the init function when the window is done loading.
    window.onload = init;
</script>
<body>
</body>
</html>